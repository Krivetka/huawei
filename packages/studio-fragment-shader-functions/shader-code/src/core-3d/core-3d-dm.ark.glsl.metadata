{
    "compatibility_info": {
        "version": "2.0",
        "type": "metafile"
    },
    "metainfo": {
        "iid": "59a52dca-fb58-4c6c-a5b2-19f2dcde75a3",
        "uri": "project://packages/studio-fragment-shader-functions/shader-code/src/core-3d/core-3d-dm.ark.glsl",
        "sha1": "d18d94ec8422b799605663c949c6a683a2a2744a",
        "spec": {
            "$meta": {
                "version": "1.0"
            },
            "$root": {
                "$classId": "68089ffa-cefa-11ed-afa1-0242ac120002",
                "$name": "ShaderCodeAsset",
                "$instanceId": "0000d9cb-16b5-235c-e40e-05850700c46d",
                "$properties": {
                    "Thumbnail": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "",
                        "defaultValue": "",
                        "flags": 225
                    },
                    "MediaType": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "application/vnd.ark.shader-code",
                        "defaultValue": "",
                        "flags": 225
                    },
                    "IsDirty": {
                        "$classId": "cd2fd49b-c6b0-14bd-5072-6f7065727479",
                        "value": true,
                        "defaultValue": true,
                        "flags": 227
                    },
                    "GeneratorSourceUri": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "",
                        "defaultValue": "",
                        "flags": 235
                    },
                    "IsGenerated": {
                        "$classId": "cd2fd49b-c6b0-14bd-5072-6f7065727479",
                        "value": false,
                        "defaultValue": false,
                        "flags": 235
                    },
                    "Iid": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "59a52dca-fb58-4c6c-a5b2-19f2dcde75a3",
                        "defaultValue": "",
                        "flags": 235
                    },
                    "Tooltip": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "",
                        "defaultValue": "",
                        "flags": 235
                    },
                    "IsBuiltIn": {
                        "$classId": "cd2fd49b-c6b0-14bd-5072-6f7065727479",
                        "value": false,
                        "defaultValue": false,
                        "flags": 235
                    },
                    "Size": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "",
                        "defaultValue": "",
                        "flags": 235
                    },
                    "Uri": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "project://packages/studio-fragment-shader-functions/shader-code/src/core-3d/core-3d-dm.ark.glsl",
                        "defaultValue": "",
                        "flags": 225
                    },
                    "Category": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "",
                        "defaultValue": "",
                        "flags": 225
                    },
                    "IsValid": {
                        "$classId": "cd2fd49b-c6b0-14bd-5072-6f7065727479",
                        "value": true,
                        "defaultValue": true,
                        "flags": 235
                    },
                    "Name": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "core-3d-dm.ark.glsl",
                        "defaultValue": "",
                        "flags": 225
                    },
                    "ModifiedTimestamp": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "133756347808216541",
                        "defaultValue": "",
                        "flags": 235
                    },
                    "Code": {
                        "$classId": "4c56efce-a00b-20a3-5072-6f7065727479",
                        "value": "\r\n\r\n#ifndef SHADERS__COMMON__CORE3D_DM_BLOCKS_H\r\n#define SHADERS__COMMON__CORE3D_DM_BLOCKS_H\r\n\r\n//#include \"render/shaders/common/render_post_process_blocks.h\"\r\n#include \"studio-fragment-shader-functions/render/post-process.h\"\r\n\r\n#include \"3d/shaders/common/3d_dm_structures_common.h\"\r\n#include \"3d/shaders/common/3d_dm_inplace_sampling_common.h\"\r\n#include \"3d/shaders/common/3d_dm_lighting_common.h\"\r\n#include \"3d/shaders/common/3d_dm_shadowing_common.h\"\r\n#include \"3d/shaders/common/3d_dm_target_packing_common.h\"\r\n\r\n#define BLOCK_EPSILON 0.0001\r\n\r\n// Needs to be included after the descriptor set descriptions\r\n/// Default Material BRDF\r\nstruct DefaultMaterialBrdfDataStruct {\r\n    /// Material f0\r\n    CORE_RELAXEDP vec4 f0;\r\n\r\n    /// Material diffuse color\r\n    /// @displayName diffuse color\r\n    CORE_RELAXEDP vec3 diffuseColor;\r\n\r\n    /// Material roughness\r\n    /// @displayName roughness\r\n    CORE_RELAXEDP float roughness;\r\n\r\n    /// @displayName alpha^2\r\n    CORE_RELAXEDP float alpha2;\r\n\r\n    /// Shading normal\r\n    /// @displayName normal\r\n    vec3 normal;\r\n};\r\n\r\n/*\r\n * GetFragInstanceIndex free function\r\n */\r\nuint GetFragInstanceIndex()\r\n{\r\n    uint instanceIdx = 0U;\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_GPU_INSTANCING_BIT) == CORE_MATERIAL_GPU_INSTANCING_BIT) {\r\n        instanceIdx = GetUnpackFlatIndicesInstanceIdx(inIndices);\r\n    }\r\n    return instanceIdx;\r\n}\r\n\r\n/**\r\n * Provides time information for the scene.\r\n *\r\n * @displayName Time Info\r\n * @out scence \u0394t - Scene delta time (ms). todo clarify/confirm\r\n * @out tick \u0394t - Tick delta time (ms). todo clarfiy/confirm\r\n * @out elapsed time - Tick total time (s).\r\n * @out frame count - Frame index. (todo clarify - starts at 0 or 1?)\r\n */\r\nvoid SceneTimeBlock(out float sceneDeltaTime, out float tickDeltaTime, out float tickTotalTime, out uint frameIndex)\r\n{\r\n    sceneDeltaTime = uGeneralData.sceneTimingData.x;\r\n    tickDeltaTime = uGeneralData.sceneTimingData.y;\r\n    tickTotalTime = uGeneralData.sceneTimingData.z;\r\n    frameIndex = floatBitsToUint(uGeneralData.sceneTimingData.w);\r\n}\r\n\r\n/**\r\n * @displayName Color Output\r\n * @in color - Final color output of this shader graph.\r\n */\r\nvoid OutputColorBlock(in vec4 color = vec4(0,0,0,1))\r\n{\r\n    outColor = color;\r\n    // multiply with alpha\r\n    outColor.rgb = clamp(outColor.rgb * outColor.a, 0.0, CORE_HDR_FLOAT_CLAMP_MAX_VALUE);\r\n}\r\n\r\n/**\r\n * @displayName Velocity and Normal Output\r\n * @in worldPos - Current world position.\r\n * @in prevWorldPos - Previous frame world position.\r\n * @in normal - Per pixel normal.\r\n */\r\nvoid OutputVelocityAndNormalBlock(in vec3 worldPos = vec3(0,0,0), in vec3 prevWorldPos = vec3(0,0,0), in vec3 normal = vec3(0,0,0))\r\n{\r\n    outVelocityNormal = GetPackVelocityAndNormal(GetFinalCalculatedVelocity(worldPos.xyz, prevWorldPos.xyz), normal);\r\n}\r\n\r\n/**\r\n * The coordinates of the current fragment (gl_FragCoord)\r\n *\r\n * @displayName Fragment Coordinates\r\n * @out coordinates - gl_FragCoord.\r\n */\r\nvoid FragCoordBlock(out vec4 outFragCoord)\r\n{\r\n    outFragCoord = gl_FragCoord;\r\n}\r\n\r\n/**\r\n * Todo write clarifying description\r\n *\r\n * @displayName Screen UV\r\n * @out UV coordinates - UV coordinates of current screen/viewport.\r\n */\r\nvoid ScreenUvBlock(out vec2 outUv)\r\n{\r\n    CORE_GET_FRAGCOORD_UV(outUv, gl_FragCoord.xy, uGeneralData.viewportSizeInvViewportSize.zw);\r\n}\r\n\r\n/**\r\n * World position of the current fragment.\r\n *\r\n * @displayName World Position\r\n * @out position - World position of the current fragment.\r\n */\r\nvoid WorldPositionBlock(out vec3 outPos)\r\n{\r\n    outPos = inPos;\r\n}\r\n\r\n/**\r\n * World position of the current fragment.\r\n *\r\n * @displayName Input World Position\r\n * @out position - World position of the current fragment.\r\n */\r\nvoid InputWorldPositionBlock(out vec3 outPos)\r\n{\r\n    outPos = inPos;\r\n}\r\n\r\n/**\r\n * Previous frame world position of the current fragment.\r\n * Can be used e.g. to calculate velocity from the current frame world position.\r\n *\r\n * @displayName Input Previous World Position\r\n * @out previous position - Previous frame world position of the current fragment.\r\n */\r\nvoid InputPrevWorldPositionBlock(out vec3 outPrevPos)\r\n{\r\n    outPrevPos = inPrevPosI.xyz;\r\n}\r\n\r\n/**\r\n * Get instance index of the current (sub)mesh.\r\n *\r\n * @displayName Input instance index\r\n * @out instance index - Instance index.\r\n */\r\nvoid InputInstanceIndexBlock(out uint outInstanceIdx)\r\n{\r\n    outInstanceIdx = 0U;\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_GPU_INSTANCING_BIT) == CORE_MATERIAL_GPU_INSTANCING_BIT) {\r\n        outInstanceIdx = GetUnpackFlatIndicesInstanceIdx(inIndices);\r\n    }\r\n}\r\n\r\n/**\r\n * UV channels 0 and 1.\r\n *\r\n * @displayName Input UVs\r\n * @out UV - Vec4 of two UVs, .xy = UV0, .zw = UV1.\r\n */\r\nvoid InputUvBlock(out vec4 outUv)\r\n{\r\n    outUv = inUv;\r\n}\r\n\r\n/**\r\n * Fragment shader color input.\r\n *\r\n * @displayName Input Color\r\n * @out color - Vec4 of color.\r\n */\r\nvoid InputColorBlock(out vec4 outVec)\r\n{\r\n    outVec = inColor;\r\n}\r\n\r\n/**\r\n * A vector with length 1 pointing in a direction perpendicular to the surface.\r\n * Fragment shader normal input.\r\n *\r\n * @displayName Input Normal\r\n * @out normal - Vec3 of normal.\r\n */\r\nvoid InputNormalBlock(out vec3 outVec)\r\n{\r\n    outVec = inNormal.xyz;\r\n}\r\n\r\n/**\r\n * Fragment shader tangent input.\r\n *\r\n * @displayName Input Tangent\r\n * @out tangent - Vec4 of tangent.\r\n */\r\nvoid InputTangentBlock(out vec4 outVec)\r\n{\r\n    outVec = inTangentW;\r\n}\r\n\r\n/**\r\n * The direction of the ray from the camera to the current fragment.\r\n *\r\n * @displayName Camera View Direction\r\n * @out direction - Vec3 normalized camera view direction.\r\n */\r\nvoid CameraViewDirBlock(out vec3 outCamDir)\r\n{\r\n    const uint cameraIdx = GetUnpackCameraIndex();\r\n    const vec3 camPos = uCameras[cameraIdx].viewInv[3].xyz;\r\n    outCamDir = normalize(inPos - camPos.xyz);\r\n}\r\n\r\n/**\r\n * Return vec4 of material texture info slot. todo improve description and add where the factor comes from\r\n *\r\n * @displayName Material Texture Slot\r\n * @in texture slot - Slot index of material texture info.\r\n * @out texture sample - The output vec4 containing the sampled texture color with applied factor.\r\n */\r\nvoid MaterialTextureInfoSlotBlock(in uint materialIndexSlot, out vec4 outCol)\r\n{\r\n    const uint maxCount = min(materialIndexSlot, CORE_MATERIAL_SAMPTEX_COUNT);\r\n    const uint texCoordInfoBit = (1 << maxCount);\r\n    const uint texCoordIdx = maxCount + CORE_MATERIAL_PACK_TEX_BASE_COLOR_UV_IDX;\r\n    const vec2 uv = GetFinalSamplingUV(inUv, texCoordInfoBit, texCoordIdx);\r\n    const vec4 factor = GetUnpackMaterialTextureInfoSlotFactor(maxCount, GetFragInstanceIndex());\r\n    // NOTE: baseColor is on its own for automatic hwbuffer/oes support\r\n    if (maxCount == 0) {\r\n        outCol = texture(uSampTextureBase, uv) * factor;\r\n    } else {\r\n        outCol = texture(uSampTextures[maxCount - 1], uv) * factor;\r\n    }\r\n}\r\n\r\n/**\r\n * Sample material slot texture with given uv\r\n *\r\n * @displayName Sampled Material Texture Slot\r\n * @in texture sampler - Slot index of material texture info.\r\n * @in UV coords - UV coordinates for sampling.\r\n * @out sample - Sampled texture with given UVs.\r\n */\r\nvoid MaterialTextureInfoSlotSampleBlock(in uint materialIndexSlot, in vec2 uv, out vec4 outCol)\r\n{\r\n    const uint maxCount = min(materialIndexSlot, CORE_MATERIAL_SAMPTEX_COUNT);\r\n    // NOTE: baseColor is on its own for automatic hwbuffer/oes support\r\n    if (maxCount == 0) {\r\n        outCol = texture(uSampTextureBase, uv);\r\n    } else {\r\n        outCol = texture(uSampTextures[maxCount - 1], uv);\r\n    }\r\n}\r\n\r\n/**\r\n * Sample material slot normal texture with given uv\r\n *\r\n * @displayName Sampled Material Normal Texture Slot\r\n * @in texture slot - Slot index of material texture info.\r\n * @in UV coords - UV coordinates for sampling.\r\n * @out Normal - Sampled normal from tangent space.\r\n */\r\nvoid MaterialTextureInfoSlotSampleNormalBlock(in uint materialIndexSlot, in vec2 uv, out vec3 outNor)\r\n{\r\n    const uint maxCount = min(materialIndexSlot, CORE_MATERIAL_SAMPTEX_COUNT);\r\n    // NOTE: baseColor is on its own for automatic hwbuffer/oes support\r\n    const vec4 factor = GetUnpackMaterialTextureInfoSlotFactor(maxCount, GetFragInstanceIndex());\r\n    if (maxCount == 0) {\r\n        outNor = texture(uSampTextureBase, uv).rgb * factor.xyz;\r\n    } else {\r\n        outNor = texture(uSampTextures[maxCount - 1], uv).rgb * factor.xyz;\r\n    }\r\n    outNor = normalize(2.0 * outNor - 1.0);\r\n    const vec3 normNormal = normalize(inNormal.xyz);\r\n    const vec3 theTangent = normalize(inTangentW.xyz);\r\n    const vec3 theBitangent = cross(normNormal.xyz, theTangent.xyz) * inTangentW.w;\r\n    const mat3 tbn = mat3(theTangent.xyz, theBitangent.xyz, normNormal.xyz);\r\n    outNor = normalize(tbn * outNor);\r\n\r\n    outNor = gl_FrontFacing ? outNor : -outNor;\r\n}\r\n\r\n/**\r\n * Todo write description\r\n *\r\n * @displayName Material Texture Slot Factor\r\n * @in texture slot - [0] Slot index of material texture info.\r\n * @out factor - Vec4 factor of material texture info.\r\n */\r\nvoid MaterialTextureInfoSlotFactorBlock(in uint materialIndexSlot, out vec4 outFactor)\r\n{\r\n    const uint maxCount = min(materialIndexSlot, CORE_MATERIAL_SAMPTEX_COUNT);\r\n    outFactor = GetUnpackMaterialTextureInfoSlotFactor(maxCount, GetFragInstanceIndex());\r\n}\r\n\r\n/**\r\n * Get material texture info slot uv (TODO: improve description)\r\n *\r\n * @displayName Material Texture Slot UV\r\n * @in texture slot - [0] Slot index of material texture info.\r\n * @out UV - Vec2 UV coordinates.\r\n */\r\nvoid MaterialTextureInfoSlotUvBlock(in uint materialIndexSlot, out vec2 outUv)\r\n{\r\n    const uint maxCount = min(materialIndexSlot, CORE_MATERIAL_SAMPTEX_COUNT);\r\n    const uint texCoordInfoBit = (1 << maxCount);\r\n    const uint texCoordIdx = maxCount + CORE_MATERIAL_PACK_TEX_BASE_COLOR_UV_IDX;\r\n    outUv = GetFinalSamplingUV(inUv, texCoordInfoBit, texCoordIdx);\r\n}\r\n\r\n/**\r\n * Provides total elapsed time from the start of the scene.\r\n *\r\n * @displayName Elapsed Time\r\n * @out t - Tick total time in seconds.\r\n */\r\nvoid ElapsedTimeBlock(out float totalTimeInSeconds)\r\n{\r\n    totalTimeInSeconds = uGeneralData.sceneTimingData.z;\r\n}\r\n\r\n/**\r\n * Performs default base color sampling and handling for a material.\r\n * - Discards fragments based on alpha cutoff.\r\n * - Handles opaque materials with 1.0 alpha.\r\n *\r\n * @displayName Base Color Sampler\r\n * @out base color - The output vec4 containing the calculated base color.\r\n */\r\nvoid BaseColorSampleBlock(out vec4 baseColor)\r\n{\r\n    // NOTE: blend mode opaque alpha should be 1.0 from this calculation\r\n    const uint instanceIdx = GetFragInstanceIndex();\r\n    baseColor = GetBaseColorSample(inUv) * GetUnpackBaseColor(instanceIdx) * inColor;\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_ADDITIONAL_SHADER_DISCARD_BIT) ==\r\n        CORE_MATERIAL_ADDITIONAL_SHADER_DISCARD_BIT) {\r\n        if (baseColor.a < GetUnpackAlphaCutoff(instanceIdx)) {\r\n            discard;\r\n        }\r\n    }\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_OPAQUE_BIT) == CORE_MATERIAL_OPAQUE_BIT) {\r\n        baseColor.a = 1.0;\r\n    } else {\r\n        baseColor = Unpremultiply(baseColor);\r\n    }\r\n}\r\n\r\n/**\r\n * Todo write more helpful description\r\n * Default normals sampling and handling block.\r\n * Handles normal and clearcoat normal.\r\n * The values are returned vec3 values.\r\n *\r\n * @displayName Sampled Normals\r\n * @out normal - The output vec3 containing the calculated normal.\r\n * @out clearcoat normal - The output vec3 containing the calculated clearcoat normal.\r\n */\r\nvoid NormalsSampleBlock(out vec3 normal, out vec3 clearcoatNormal)\r\n{\r\n    const vec3 normNormal = normalize(inNormal.xyz);\r\n    normal = normNormal;\r\n    clearcoatNormal = normNormal;\r\n    // clear coat normal is calculated if normal_map_bit and if clearcoat_bit\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_NORMAL_MAP_BIT) == CORE_MATERIAL_NORMAL_MAP_BIT) {\r\n        vec3 normalSample = GetNormalSample(inUv);\r\n        const float normalScale = GetUnpackNormalScale(GetFragInstanceIndex());\r\n        normalSample = normalize((2.0 * normalSample - 1.0) * vec3(normalScale, normalScale, 1.0f));\r\n        const vec3 tangent = normalize(inTangentW.xyz);\r\n        const vec3 bitangent = cross(normNormal, tangent.xyz) * inTangentW.w;\r\n        const mat3 tbn = mat3(tangent.xyz, bitangent.xyz, normNormal);\r\n        normal = normalize(tbn * normalSample);\r\n        if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_CLEARCOAT_BIT) == CORE_MATERIAL_CLEARCOAT_BIT) {\r\n            vec3 ccNormalSample = GetClearcoatNormalSample(inUv);\r\n            // cc normal scale not yet supported\r\n            ccNormalSample = normalize((2.0 * ccNormalSample - 1.0));\r\n            clearcoatNormal = normalize(tbn * ccNormalSample);\r\n        }\r\n    }\r\n\r\n    // NOTE: clearcoat normal should be front-facing as well?\r\n    // if no backface culling we flip automatically\r\n    normal = gl_FrontFacing ? normal : -normal;\r\n}\r\n\r\n/**\r\n * Performs material sampling and handling for a given base color and polygon normal, and outputs the computed BRDF\r\n * (Bidirectional Reflectance Distribution Function) values in a struct.\r\n *\r\n * @displayName Material BRDF Sampling and Handling\r\n * @in base color - Base color.\r\n * @in normal - Polygon normal of the object\r\n * @out brdf - the computed BRDF (Bidirectional Reflectance Distribution Function) values\r\n */\r\nvoid MaterialSampleBlock(in vec4 baseColor = vec4(1,1,1,1), in vec3 polygonNormal = vec3(0,1,0), out DefaultMaterialBrdfDataStruct bd)\r\n{\r\n    vec4 uv = inUv;\r\n    const uint instanceIdx = GetFragInstanceIndex();\r\n    const CORE_RELAXEDP vec4 material = GetMaterialSample(uv) * GetUnpackMaterial(instanceIdx);\r\n    bd.normal = polygonNormal;\r\n    InputBrdfData brdfData;\r\n    if (CORE_MATERIAL_TYPE == CORE_MATERIAL_SPECULAR_GLOSSINESS) {\r\n        brdfData = CalcBRDFSpecularGlossiness(baseColor, polygonNormal, material);\r\n    } else if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_SPECULAR_BIT) == CORE_MATERIAL_SPECULAR_BIT) {\r\n        const CORE_RELAXEDP vec4 specular = GetSpecularSample(inUv, instanceIdx) * GetUnpackSpecular(instanceIdx);\r\n        brdfData = CalcBRDFSpecular(baseColor, polygonNormal, material, specular);\r\n    } else {\r\n        brdfData = CalcBRDFMetallicRoughness(baseColor, polygonNormal, material);\r\n    }\r\n    bd.f0 = brdfData.f0;\r\n    bd.diffuseColor = brdfData.diffuseColor;\r\n    bd.roughness = brdfData.roughness;\r\n    bd.alpha2 = brdfData.alpha2;\r\n    bd.normal = polygonNormal;\r\n}\r\n\r\nvec3 GetIrradianceSample(const vec3 worldNormal)\r\n{\r\n    const vec3 worldNormalEnv = mat3(uEnvironmentData.envRotation) * worldNormal;\r\n    return unpackIblIrradianceSH(worldNormalEnv, uEnvironmentData.shIndirectCoefficients) *\r\n        uEnvironmentData.indirectDiffuseColorFactor.rgb;\r\n}\r\n\r\nfloat GetLodForRadianceSample(const float roughness)\r\n{\r\n    return uEnvironmentData.values.x * roughness;\r\n}\r\n\r\nvec3 GetRadianceSample(const vec3 worldReflect, const float roughness)\r\n{\r\n    const CORE_RELAXEDP float cubeLod = GetLodForRadianceSample(roughness);\r\n    const vec3 worldReflectEnv = mat3(uEnvironmentData.envRotation) * worldReflect;\r\n    return unpackIblRadiance(textureLod(uSampRadiance, worldReflectEnv, cubeLod)) *\r\n        uEnvironmentData.indirectSpecularColorFactor.rgb;\r\n}\r\n\r\n/*\r\n * @brief Obtains a transmission radiance sample based on the given fragment UVs, world reflection direction, and roughness.\r\n *\r\n * This function first tries to fetch a color from a pre-pass texture based on the given fragment UVs and level-of-detail (LOD) derived from the roughness.\r\n * If the alpha component of this color is below a threshold (0.5), it falls back to sampling the environment using the provided world reflection direction\r\n * and roughness.\r\n *\r\n * Note: The default texture used for the pre-pass is assumed to be black with zero alpha. If the alpha is below the threshold (0.5), it's assumed\r\n * that the pre-pass color is essentially \"transparent\" or \"unavailable\", and therefore the environment should be sampled directly.\r\n *\r\n * @param fragUv The UV coordinates for the fragment.\r\n * @param worldReflect The world reflection direction vector.\r\n * @param roughness Surface roughness, determines the level of detail for sampling the radiance.\r\n * @return The RGB transmission radiance sample.\r\n */\r\nvec3 GetTransmissionRadianceSample(const vec2 fragUv, const vec3 worldReflect, const float roughness)\r\n{\r\n    // NOTE: this makes a pre color selection based on alpha\r\n    // we would generally need an extra flag, the default texture is black with alpha zero\r\n    const CORE_RELAXEDP float lod = GetLodForRadianceSample(roughness);\r\n    vec4 color = textureLod(uSampColorPrePass, fragUv, lod).rgba;\r\n    if (color.a < 0.5f) {\r\n        // sample environment if the default pre pass color was 0.0 alpha\r\n        color.rgb = GetRadianceSample(worldReflect, roughness);\r\n    }\r\n    return color.rgb;\r\n}\r\n\r\n/**\r\n * Indirect lighting block with brdf and base color input.\r\n *\r\n * @displayName Indirect Lighting\r\n * @in brdf - BRDF data (Bidirectional Reflectance Distribution Function)\r\n * @in color - Base color to be lit\r\n * @out color - Lit color\r\n */\r\nvoid IndirectLightingBlock(in DefaultMaterialBrdfDataStruct bd, in vec3 color, out vec3 outCol)\r\n{\r\n    outCol = color;\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_INDIRECT_LIGHT_RECEIVER_BIT) ==\r\n        CORE_MATERIAL_INDIRECT_LIGHT_RECEIVER_BIT) {\r\n        const uint cameraIdx = GetUnpackCameraIndex();\r\n        const vec3 camPos = uCameras[cameraIdx].viewInv[3].xyz;\r\n\r\n        const vec3 V = normalize(camPos.xyz - inPos);\r\n        const vec3 N = bd.normal;\r\n        const float NoV = clamp(dot(N, V), CORE3D_PBR_LIGHTING_EPSILON, 1.0);\r\n\r\n        const CORE_RELAXEDP float ao = clamp(GetAOSample(inUv) * GetUnpackAO(GetFragInstanceIndex()), 0.0, 1.0);\r\n        // lambert baked into irradianceSample (SH)\r\n        CORE_RELAXEDP\r\n        vec3 irradiance = GetIrradianceSample(N) * bd.diffuseColor * ao;\r\n\r\n        const vec3 worldReflect = reflect(-V, N);\r\n        const CORE_RELAXEDP vec3 fIndirect = EnvBRDFApprox(bd.f0.xyz, bd.roughness, NoV);\r\n        // ao applied after clear coat\r\n        CORE_RELAXEDP\r\n        vec3 radianceSample = GetRadianceSample(worldReflect, bd.roughness);\r\n        CORE_RELAXEDP\r\n        vec3 radiance = radianceSample * fIndirect;\r\n\r\n        // apply ao for indirect specular as well (cheap version)\r\n        #if 1\r\n            radiance *= ao * SpecularHorizonOcclusion(worldReflect, inNormal);\r\n        #else\r\n            radiance *= EnvSpecularAo(ao, NoV, roughness) * SpecularHorizonOcclusion(worldReflect, inNormal);\r\n        #endif\r\n\r\n        outCol += (irradiance + radiance);\r\n    }\r\n}\r\n\r\n/**\r\n * Direct lighting block with brdf and base color input.\r\n *\r\n * @displayName Direct Lighting\r\n * @in brdf - BRDF data (Bidirectional Reflectance Distribution Function)\r\n * @in color - Base color to be lit\r\n * @out color - Lit color\r\n */\r\nvoid DirectLightingBlock(in DefaultMaterialBrdfDataStruct bd, in vec3 color, out vec3 outCol)\r\n{\r\n    outCol = color;\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_PUNCTUAL_LIGHT_RECEIVER_BIT) ==\r\n        CORE_MATERIAL_PUNCTUAL_LIGHT_RECEIVER_BIT) {\r\n        const uint cameraIdx = GetUnpackCameraIndex();\r\n        const vec3 camPos = uCameras[cameraIdx].viewInv[3].xyz;\r\n\r\n        const vec3 V = normalize(camPos.xyz - inPos);\r\n        const float NoV = clamp(dot(bd.normal, V), CORE3D_PBR_LIGHTING_EPSILON, 1.0);\r\n        ShadingData shadingData;\r\n        shadingData.pos = inPos.xyz;\r\n        shadingData.N = bd.normal;\r\n        shadingData.NoV = NoV;\r\n        shadingData.V = V;\r\n        shadingData.f0 = bd.f0;\r\n        shadingData.alpha2 = bd.alpha2;\r\n        shadingData.diffuseColor = bd.diffuseColor;\r\n\r\n        outCol = CalculateLighting(shadingData, CORE_MATERIAL_FLAGS);\r\n    }\r\n}\r\n\r\nbool ValidNormalValue(vec3 normal)\r\n{\r\n    const float maxVal = max(max(abs(normal.x), abs(normal.y)), abs(normal.z));\r\n    return (maxVal > BLOCK_EPSILON) ? true : false;\r\n}\r\n\r\nbool ValidClearcoatValue(float val)\r\n{\r\n    return (val > BLOCK_EPSILON) ? true : false;\r\n}\r\n\r\nbool ValidSheenValue(float val)\r\n{\r\n    return (val > BLOCK_EPSILON) ? true : false;\r\n}\r\n\r\nbool ValidTransmissionValue(float val)\r\n{\r\n    return (val > BLOCK_EPSILON) ? true : false;\r\n}\r\n\r\n/**\r\n * Calculates a lit color using the BRDF lighting model.\r\n *\r\n * @displayName BRDF Lighting\r\n * @in base color - [1, 1, 1] Albedo/Base color. Base color expected to be unpremultiplied with alpha (Base Color Block)\r\n * @in alpha - [1] Alpha value (0-1).\r\n * @in alpha cutoff - [1] Float alpha cutoff value (0-1, ignored if 1).\r\n * @in normal - [0, 0, 0] Vec3 Surface normal (ignored if zero).\r\n * @in roughness - [1] Roughness value (0-1).\r\n * @in metallic - [1] Metallic value (0.0f = dielectric, 1.0f = metallic).\r\n * @in reflectance - [0.04] F0 reflectance (0-1) - the amount of light that bounces back\r\n *                          when coming from perpendicular to the surface.\r\n * @in emissive - [0, 0, 0] Emissive (ignored if zero).\r\n * @in ambient occlusion - [1] Ambient Occlusion (0-1, ignored if 1) - AO value\r\n * @in clearcoat - [0] Clearcoat value (0-1, ignored if zero).\r\n * @in clearcoat roughness - [0] Clearcoat roughness value (0-1, ignored if 0)\r\n * @in clearcoat normal - [0, 0, 0] Clearcoat normal vector (ignored if this or clearcoat is zero).\r\n * @in transmission - [0] Transmission value (0-1, ignored if zero).\r\n * @in sheen color - [0, 0, 0] Sheen color (ignored if sheen is zero).\r\n * @in sheen - [0] Sheen value (0-1, ignored if zero).\r\n * @in sheen roughness - [0] Sheen roughness value (0-1, ignored if sheen is zero).\r\n * @in specular - [0, 0, 0, 0] Specular vec4 with strength in alpha (ignored if alpha is zero).\r\n *\r\n * @out BRDF - Calculated lit color.\r\n */\r\nvoid BRDFBlock(in vec3 baseColor = vec3(1,1,1), in float alpha = 1, in float alphaCutoff = 1, in vec3 norm, in float roughness = 1, in float metallic = 1,\r\n    in float reflectance = 0.04, in vec3 emissive, in float ao = 1, in float clearcoat, in float clearcoatRoughness,\r\n    in vec3 clearcoatNormal, in float transmission, in vec3 sheenColor, in float sheen, in float sheenRoughness,\r\n    in vec4 specular, out vec4 outCol)\r\n{\r\n    outCol = vec4(0.0, 0.0, 0.0, alpha);\r\n    // alpha cutoff\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_ADDITIONAL_SHADER_DISCARD_BIT) ==\r\n        CORE_MATERIAL_ADDITIONAL_SHADER_DISCARD_BIT) {\r\n        if (alpha < alphaCutoff) {\r\n            discard;\r\n        }\r\n    }\r\n\r\n    // normal\r\n    vec3 normal = normalize(ValidNormalValue(norm) ? norm : inNormal);\r\n    normal = gl_FrontFacing ? normal : -normal;\r\n\r\n    // material\r\n    const vec4 material = vec4(0.0, roughness, metallic, reflectance);\r\n    InputBrdfData brdfData;\r\n    // NOTE: does not implement CORE_MATERIAL_SPECULAR_GLOSSINESS\r\n    if (specular.w > BLOCK_EPSILON) {\r\n        brdfData = CalcBRDFSpecular(vec4(baseColor.rgb, alpha), inNormal, material, specular);\r\n    } else {\r\n        brdfData = CalcBRDFMetallicRoughness(vec4(baseColor.rgb, alpha), inNormal, material);\r\n    }\r\n\r\n    const uint cameraIdx = GetUnpackCameraIndex();\r\n    const vec3 camPos = uCameras[cameraIdx].viewInv[3].xyz;\r\n    const vec3 V = normalize(camPos.xyz - inPos);\r\n    const float NoV = clamp(dot(normal, V), CORE3D_PBR_LIGHTING_EPSILON, 1.0);\r\n\r\n    const bool hasClearcoat = ValidClearcoatValue(clearcoat);\r\n    const bool hasSheen = ValidSheenValue(sheen);\r\n    const bool hasTransmission = ValidTransmissionValue(transmission);\r\n\r\n    ClearcoatShadingVariables clearcoatSV;\r\n    if (hasClearcoat) {\r\n        clearcoatSV.cc = clearcoat;\r\n        clearcoatSV.ccRoughness = clearcoatRoughness;\r\n        // geometric correction doesn't behave that well with clearcoat due to it being basically 0 roughness\r\n        clearcoatSV.ccRoughness = clamp(clearcoatSV.ccRoughness, CORE_BRDF_MIN_ROUGHNESS, 1.0);\r\n        CORE_RELAXEDP const float ccAlpha = clearcoatSV.ccRoughness * clearcoatSV.ccRoughness;\r\n        clearcoatSV.ccAlpha2 = ccAlpha * ccAlpha;\r\n        clearcoatSV.ccNormal = normalize(ValidNormalValue(clearcoatNormal) ? clearcoatNormal : inNormal);\r\n    }\r\n\r\n    SheenShadingVariables sheenSV;\r\n    if (hasSheen) {\r\n        sheenSV.sheenColor = sheenColor;\r\n        sheenSV.sheenColorMax = max(sheenSV.sheenColor.r, max(sheenSV.sheenColor.g, sheenSV.sheenColor.b));\r\n        sheenSV.sheenRoughness = sheenRoughness;\r\n        sheenSV.sheenBRDFApprox = EnvBRDFApproxSheen(NoV, sheenSV.sheenRoughness * sheenSV.sheenRoughness);\r\n    }\r\n\r\n    if (hasTransmission) {\r\n        brdfData.diffuseColor *= (1.0 - transmission);\r\n    }\r\n\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_PUNCTUAL_LIGHT_RECEIVER_BIT) ==\r\n        CORE_MATERIAL_PUNCTUAL_LIGHT_RECEIVER_BIT) {\r\n        ShadingData shadingData;\r\n        shadingData.pos = inPos.xyz;\r\n        shadingData.N = normal;\r\n        shadingData.NoV = NoV;\r\n        shadingData.V = V;\r\n        shadingData.f0 = brdfData.f0;\r\n        shadingData.alpha2 = brdfData.alpha2;\r\n        shadingData.diffuseColor = brdfData.diffuseColor;\r\n        uint materialFlags = CORE_MATERIAL_FLAGS;\r\n        materialFlags |= (hasClearcoat) ? CORE_MATERIAL_CLEARCOAT_BIT : 0;\r\n        materialFlags |= (hasSheen) ? CORE_MATERIAL_SHEEN_BIT : 0;\r\n        materialFlags |= (hasTransmission) ? CORE_MATERIAL_TRANSMISSION_BIT : 0;\r\n\r\n        outCol.rgb += CalculateLighting(shadingData, clearcoatSV, sheenSV, materialFlags);\r\n    }\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_INDIRECT_LIGHT_RECEIVER_BIT) ==\r\n        CORE_MATERIAL_INDIRECT_LIGHT_RECEIVER_BIT) {\r\n        // lambert baked into irradianceSample (SH)\r\n        CORE_RELAXEDP vec3 irradiance = GetIrradianceSample(normal) * brdfData.diffuseColor * ao;\r\n\r\n        const vec3 worldReflect = reflect(-V, normal);\r\n        const CORE_RELAXEDP vec3 fIndirect = EnvBRDFApprox(brdfData.f0.xyz, brdfData.roughness, NoV);\r\n        // ao applied after clear coat\r\n        CORE_RELAXEDP vec3 radianceSample = GetRadianceSample(worldReflect, brdfData.roughness);\r\n        CORE_RELAXEDP vec3 radiance = radianceSample * fIndirect;\r\n\r\n        if (hasSheen) {\r\n            AppendIndirectSheen(sheenSV, radianceSample, alpha, irradiance, radiance);\r\n        }\r\n        if (hasClearcoat) {\r\n            const vec3 ccWorldReflect = reflect(-V, clearcoatSV.ccNormal);\r\n            const vec3 ccRadianceSample = GetRadianceSample(ccWorldReflect, clearcoatSV.ccRoughness);\r\n            AppendIndirectClearcoat(clearcoatSV, ccRadianceSample, alpha, V, irradiance, radiance);\r\n        }\r\n        if (hasTransmission) {\r\n            vec2 fragUv;\r\n            CORE_GET_FRAGCOORD_UV(fragUv, gl_FragCoord.xy, uGeneralData.viewportSizeInvViewportSize.zw);\r\n            // NOTE: ATM use direct refract (no sphere mapping)\r\n            const vec3 rr = -V; // refract(-V, N, 1.0 / ior);\r\n            const CORE_RELAXEDP vec3 transmissionRadianceSample = GetTransmissionRadianceSample(fragUv, rr, brdfData.roughness);\r\n\r\n            AppendIndirectTransmission(transmissionRadianceSample, baseColor.rgb, transmission, irradiance);\r\n        }\r\n        // apply ao for indirect specular as well (cheap version)\r\n#if 1\r\n        radiance *= ao * SpecularHorizonOcclusion(worldReflect, inNormal);\r\n#else\r\n        radiance *= EnvSpecularAo(ao, NoV, brdfData.roughness) * SpecularHorizonOcclusion(worldReflect, inNormal);\r\n#endif\r\n\r\n        outCol.rgb += (irradiance + radiance);\r\n    }\r\n    outCol.rgb += emissive;\r\n}\r\n\r\n/**\r\n * todo write description\r\n *\r\n * @displayName Anisotropic BRDF Lighting\r\n * @in base color - [1, 1, 1] Albedo/Base color.\r\n * @in alpha - [1] Alpha value (0-1).\r\n * @in alpha cutoff - [1] Alpha cutoff value (0-1, ignored if 1).\r\n * @in normal - [0, 0, 0] Normal (ignored if zero).\r\n * @in roughness - [1] Roughness value (0-1).\r\n * @in metallic - [1] Metallic value (0-1).\r\n * @in reflectance - [0.04] Reflectance (F0)\r\n * @in emissive - [0, 0, 0] Emissive (ignored if zero).\r\n * @in ambient occlusion - [1] Ambient occlusion value (0-1, ignored if 1).\r\n * @in clearcoat - [0] Clearcoat value (0-1, ignored if zero).\r\n * @in clearcoat roughness - [0] Clearcoat roughness value (0-1, ignored if clearcoat is zero).\r\n * @in clearcoat normal - [0, 0, 0] Clearcoat normal (ignored if zero or clearcoat is zero).\r\n * @in transmission - [0] Transmission value (0-1, ignored if zero).\r\n * @in sheen color - [0, 0, 0] Sheen color (ignored if sheen is zero).\r\n * @in sheen - [0] Sheen value (0-1, ignored if zero).\r\n * @in sheen roughness - [0] Sheen roughness value (0-1, ignored if sheen is zero).\r\n * @in specular - [0, 0, 0, 0] Specular vec4 with strength in alpha (ignored if alpha is zero).\r\n * @in anisotropy - [0] Anisotropy value (-1\u20261).\r\n * @in anisotropic direction - [0, 0, 0] Anisotropic direction vec3 (-1\u20261).\r\n *\r\n * @out color - Calculated lit color.\r\n */\r\nvoid BRDFAnisotropicBlock(in vec3 baseColor = vec3(1,1,1), in float alpha = 1.0, in float alphaCutoff = 1.0, in vec3 norm, in float roughness = 1,\r\n    in float metallic = 1, in float reflectance = 0.04, in vec3 emissive, in float ao = 1, in float clearcoat,\r\n    in float clearcoatRoughness, in vec3 clearcoatNormal, in float transmission, in vec3 sheenColor, in float sheen,\r\n    in float sheenRoughness, in vec4 specular, in float anisotropy, in vec3 anisotropyDir, out vec4 outCol)\r\n{\r\n    outCol = vec4(0.0, 0.0, 0.0, alpha);\r\n    // alpha cutoff\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_ADDITIONAL_SHADER_DISCARD_BIT) ==\r\n        CORE_MATERIAL_ADDITIONAL_SHADER_DISCARD_BIT) {\r\n        if (alpha < alphaCutoff) {\r\n            discard;\r\n        }\r\n    }\r\n\r\n    // normal\r\n    vec3 normal = normalize(ValidNormalValue(norm) ? norm : inNormal);\r\n    normal = gl_FrontFacing ? normal : -normal;\r\n\r\n    // material\r\n    const vec4 material = vec4(0.0, roughness, metallic, reflectance);\r\n    InputBrdfData brdfData;\r\n    // NOTE: does not implement CORE_MATERIAL_SPECULAR_GLOSSINESS\r\n    if (specular.w > BLOCK_EPSILON) {\r\n        brdfData = CalcBRDFSpecular(vec4(baseColor.rgb, alpha), inNormal, material, specular);\r\n    } else {\r\n        brdfData = CalcBRDFMetallicRoughness(vec4(baseColor.rgb, alpha), inNormal, material);\r\n    }\r\n\r\n    const uint cameraIdx = GetUnpackCameraIndex();\r\n    const vec3 camPos = uCameras[cameraIdx].viewInv[3].xyz;\r\n    const vec3 V = normalize(camPos.xyz - inPos);\r\n    const float NoV = clamp(dot(normal, V), CORE3D_PBR_LIGHTING_EPSILON, 1.0);\r\n\r\n    const bool hasClearcoat = ValidClearcoatValue(clearcoat);\r\n    const bool hasSheen = ValidSheenValue(sheen);\r\n    const bool hasTransmission = ValidTransmissionValue(transmission);\r\n\r\n    ClearcoatShadingVariables clearcoatSV;\r\n    if (hasClearcoat) {\r\n        clearcoatSV.cc = clearcoat;\r\n        clearcoatSV.ccRoughness = clearcoatRoughness;\r\n        // geometric correction doesn't behave that well with clearcoat due to it being basically 0 roughness\r\n        clearcoatSV.ccRoughness = clamp(clearcoatSV.ccRoughness, CORE_BRDF_MIN_ROUGHNESS, 1.0);\r\n        CORE_RELAXEDP const float ccAlpha = clearcoatSV.ccRoughness * clearcoatSV.ccRoughness;\r\n        clearcoatSV.ccAlpha2 = ccAlpha * ccAlpha;\r\n        clearcoatSV.ccNormal = normalize(ValidNormalValue(clearcoatNormal) ? clearcoatNormal : inNormal);\r\n    }\r\n\r\n    SheenShadingVariables sheenSV;\r\n    if (hasSheen) {\r\n        sheenSV.sheenColor = sheenColor;\r\n        sheenSV.sheenColorMax = max(sheenSV.sheenColor.r, max(sheenSV.sheenColor.g, sheenSV.sheenColor.b));\r\n        sheenSV.sheenRoughness = sheenRoughness;\r\n        sheenSV.sheenBRDFApprox = EnvBRDFApproxSheen(NoV, sheenSV.sheenRoughness * sheenSV.sheenRoughness);\r\n    }\r\n\r\n    if (hasTransmission) {\r\n        brdfData.diffuseColor *= (1.0 - transmission);\r\n    }\r\n\r\n    AnisotropicShadingVariables asv;\r\n    {\r\n        const vec3 normNormal = normalize(inNormal.xyz);\r\n        const vec3 tangent = normalize(inTangentW.xyz);\r\n        const vec3 bitangent = cross(normNormal, tangent.xyz) * inTangentW.w;\r\n        const mat3 tbn = mat3(tangent.xyz, bitangent.xyz, normNormal);\r\n\r\n        asv.roughness = brdfData.roughness;\r\n        asv.alpha = asv.roughness * asv.roughness;\r\n        asv.anisotropy = anisotropy;\r\n        asv.anisotropicT = normalize(tbn * anisotropyDir);\r\n        asv.anisotropicB = normalize(cross(normNormal, asv.anisotropicT));\r\n        asv.ToV = dot(asv.anisotropicT, V);\r\n        asv.BoV = dot(asv.anisotropicB, V);\r\n    }\r\n\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_PUNCTUAL_LIGHT_RECEIVER_BIT) ==\r\n        CORE_MATERIAL_PUNCTUAL_LIGHT_RECEIVER_BIT) {\r\n        ShadingData shadingData;\r\n        shadingData.pos = inPos.xyz;\r\n        shadingData.N = normal;\r\n        shadingData.NoV = NoV;\r\n        shadingData.V = V;\r\n        shadingData.f0 = brdfData.f0;\r\n        shadingData.alpha2 = brdfData.alpha2;\r\n        shadingData.diffuseColor = brdfData.diffuseColor;\r\n        uint materialFlags = CORE_MATERIAL_FLAGS;\r\n        materialFlags |= (hasClearcoat) ? CORE_MATERIAL_CLEARCOAT_BIT : 0;\r\n        materialFlags |= (hasSheen) ? CORE_MATERIAL_SHEEN_BIT : 0;\r\n        materialFlags |= (hasTransmission) ? CORE_MATERIAL_TRANSMISSION_BIT : 0;\r\n\r\n        outCol.rgb += CalculateLighting(shadingData, asv, clearcoatSV, sheenSV, materialFlags);\r\n    }\r\n    if ((CORE_MATERIAL_FLAGS & CORE_MATERIAL_INDIRECT_LIGHT_RECEIVER_BIT) ==\r\n        CORE_MATERIAL_INDIRECT_LIGHT_RECEIVER_BIT) {\r\n        // lambert baked into irradianceSample (SH)\r\n        CORE_RELAXEDP vec3 irradiance = GetIrradianceSample(normal) * brdfData.diffuseColor * ao;\r\n\r\n        const vec3 worldReflect = GetAnistropicReflectionVector(V, normal, asv);\r\n        const CORE_RELAXEDP vec3 fIndirect = EnvBRDFApprox(brdfData.f0.xyz, brdfData.roughness, NoV);\r\n        // ao applied after clear coat\r\n        CORE_RELAXEDP vec3 radianceSample = GetRadianceSample(worldReflect, brdfData.roughness);\r\n        CORE_RELAXEDP vec3 radiance = radianceSample * fIndirect;\r\n\r\n        if (hasSheen) {\r\n            AppendIndirectSheen(sheenSV, radianceSample, alpha, irradiance, radiance);\r\n        }\r\n        if (hasClearcoat) {\r\n            const vec3 ccWorldReflect = reflect(-V, clearcoatSV.ccNormal);\r\n            const vec3 ccRadianceSample = GetRadianceSample(ccWorldReflect, clearcoatSV.ccRoughness);\r\n            AppendIndirectClearcoat(clearcoatSV, ccRadianceSample, alpha, V, irradiance, radiance);\r\n        }\r\n        if (hasTransmission) {\r\n            vec2 fragUv;\r\n            CORE_GET_FRAGCOORD_UV(fragUv, gl_FragCoord.xy, uGeneralData.viewportSizeInvViewportSize.zw);\r\n            // NOTE: ATM use direct refract (no sphere mapping)\r\n            const vec3 rr = -V; // refract(-V, N, 1.0 / ior);\r\n            const CORE_RELAXEDP vec3 transmissionRadianceSample = GetTransmissionRadianceSample(fragUv, rr, brdfData.roughness);\r\n\r\n            AppendIndirectTransmission(transmissionRadianceSample, baseColor.rgb, transmission, irradiance);\r\n        }\r\n        // apply ao for indirect specular as well (cheap version)\r\n#if 1\r\n        radiance *= ao * SpecularHorizonOcclusion(worldReflect, inNormal);\r\n#else\r\n        radiance *= EnvSpecularAo(ao, NoV, brdfData.roughness) * SpecularHorizonOcclusion(worldReflect, inNormal);\r\n#endif\r\n\r\n        outCol.rgb += (irradiance + radiance);\r\n    }\r\n    outCol.rgb += emissive;\r\n}\r\n\r\n/**\r\n * Simplified post process tonemap block with input color (todo describe difference between this and\r\n * PostProcessTonemapBlock, maybe refactor)\r\n *\r\n * @displayName Simple Tone Mapping\r\n * @in input color - [1, 1, 1]\r\n * @out output color - Output color of operation\r\n */\r\nvoid PostProcessFwTonemapBlock(in vec3 inCol = vec3(1,1,1), out vec3 outCol)\r\n{\r\n    outCol = inCol;\r\n    if (CORE_POST_PROCESS_FLAGS > 0) {\r\n        PostProcessTonemapBlock(\r\n            uPostProcessData.flags.x, uPostProcessData.factors[POST_PROCESS_INDEX_TONEMAP], outCol.rgb, outCol.rgb);\r\n    }\r\n}\r\n\r\n/**\r\n * Simplified post process dither block with input color (todo)\r\n *\r\n * @displayName Dither\r\n * @in input color - [1, 1, 1]\r\n * @out output color - Output color of operation\r\n */\r\nvoid PostProcessFwDitherBlock(in vec3 inCol, out vec3 outCol)\r\n{\r\n    outCol = inCol;\r\n    if (CORE_POST_PROCESS_FLAGS > 0) {\r\n        vec2 fragUv;\r\n        CORE_GET_FRAGCOORD_UV(fragUv, gl_FragCoord.xy, uGeneralData.viewportSizeInvViewportSize.zw);\r\n        PostProcessDitherBlock(uPostProcessData.flags.x, uPostProcessData.factors[POST_PROCESS_INDEX_VIGNETTE], fragUv,\r\n            outCol.rgb, outCol.rgb);\r\n    }\r\n}\r\n\r\n/**\r\n * Applies a simple vignette to the provided color. todo describe how this relates to PostProcessVignetteBlock.\r\n *\r\n * @displayName Simple Vignette\r\n * @in input color - [1, 1, 1]\r\n * @out output color - Output color of operation\r\n */\r\nvoid PostProcessFwVignetteBlock(in vec3 inCol = vec3(1,1,1), out vec3 outCol)\r\n{\r\n    outCol = inCol;\r\n    if (CORE_POST_PROCESS_FLAGS > 0) {\r\n        vec2 fragUv;\r\n        CORE_GET_FRAGCOORD_UV(fragUv, gl_FragCoord.xy, uGeneralData.viewportSizeInvViewportSize.zw);\r\n        PostProcessVignetteBlock(uPostProcessData.flags.x, uPostProcessData.factors[POST_PROCESS_INDEX_VIGNETTE],\r\n            fragUv, outCol.rgb, outCol.rgb);\r\n    }\r\n}\r\n\r\n#endif // SHADERS__COMMON__CORE3D_DM_BLOCKS_H\r\n",
                        "defaultValue": "",
                        "flags": 227
                    }
                }
            }
        }
    }
}